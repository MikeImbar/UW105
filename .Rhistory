num_landmarks_df_colnames <- paste0("EDJ", c(1:2))
}
if(analysis == "EDJ CEJ"){
num_landmarks_df_colnames <- c(num_landmarks_df_colnames, "CEJ")
}
} else {
num_landmarks_df_colnames <- "CEJ"
}
colnames(num_landmarks_df) <-  num_landmarks_df_colnames
num_landmarks_df
if(analysis %in% c("EDJ CEJ", "EDJ")){
print("Minimum number of landmarks:")
for(l in 1:length(minEDJ)){
print(paste0(paste0("EDJ",l), ": ", min(unlist(minEDJ[[l]]))))
}
EDJ_nPoints <- vector("list", length = number_of_f_points)
names(EDJ_nPoints) <- paste0("EDJ", 1:number_of_f_points)
# define the number of points for each EDJ curve. EDJ1, EDJ2 etc...
points_per_curve <- c(20,
40)
for(i in 1:number_of_f_points){
EDJ_nPoints[[i]] <- points_per_curve[i]
}
# define the numer of points for the CEJ
if(analysis == "EDJ CEJ"){
print(paste0("CEJ: ", min(minCEJ)))
CEJ<-50
}
} else {
print(paste0("CEJ: ", min(minCEJ)))
CEJ<-60
}
# places equidistant semi-landmarks along the splines
# combined<-list()
eq_CEJ <- NULL
eq_EDJ <- NULL
if(analysis %in% c("EDJ CEJ", "EDJ")){
one_spline <- EDJ_spline_mains$spline_1m[[1]]
npoints <- EDJ_nPoints$EDJ1[[1]]
eq_EDJ <- mapply(function(spline_group, npoints_group) {
mapply(function(one_spline, npoints) {
digit.curves(start = one_spline[1,], curve = one_spline, nPoints = npoints, closed = FALSE)
}, spline_group, npoints_group, SIMPLIFY = FALSE)
}, EDJ_spline_mains, EDJ_nPoints, SIMPLIFY = FALSE)
if(analysis == "EDJ CEJ"){
for(d in 1:length(CEJ_splines_binded)){
eq_CEJ[[d]]<-digit.curves(start=CEJ_splines_binded[[d]][1,],curve=CEJ_splines_binded[[d]],nPoints=CEJ,closed=T)
}
}
} else if(analysis == "CEJ"){
for(d in 1:length(CEJ_splines_binded)){
eq_CEJ[[d]]<-digit.curves(start=CEJ_splines_binded[[d]][1,],curve=CEJ_splines_binded[[d]],nPoints=CEJ,closed=T)
# combined[[d]]<-rbind(eq_CEJ[[d]][1:(length(eq_CEJ[[d]][,1])),])
}
}
# Write how many landmarks are used for each section
if(analysis == "EDJ CEJ"){
combined_num_lands <- c(points_per_curve, CEJ)
} else if(analysis == "EDJ"){
combined_num_lands <- points_per_curve
} else {
combined_num_lands <- CEJ
}
num_landmarks_df <- data.frame(matrix(combined_num_lands, ncol = length(combined_num_lands)))
if(analysis %in% c("EDJ", "EDJ CEJ")){
if(any(grepl("M", position))){
num_landmarks_df_colnames <- paste0("EDJ", c(1:4))
} else {
num_landmarks_df_colnames <- paste0("EDJ", c(1:2))
}
if(analysis == "EDJ CEJ"){
num_landmarks_df_colnames <- c(num_landmarks_df_colnames, "CEJ")
}
} else {
num_landmarks_df_colnames <- "CEJ"
}
colnames(num_landmarks_df) <-  num_landmarks_df_colnames
# combine landmarks
combined <- combine_equidistant_landmarks(eq_EDJ, eq_CEJ, analysis)
NewCoordsArray <- array(as.numeric(unlist(combined)), dim=c(nrow(combined[[1]]), ncol(combined[[1]]) ,length(combined)))
for(i in 1:dim(NewCoordsArray)[3]){
if(any(is.na(NewCoordsArray[,,i]))){
print(paste0("NA detected in the landmark coordinates of this specimens, check landmarks! ", spec_names[i]))
}
}
a<-1
clear3d("shapes")
if(analysis %in% c("EDJ CEJ", "CEJ")){
plot_boundaries <- spline_plot_boundaries(CEJ_splines_binded)
splines_to_plot <- CEJ_splines_binded
} else {
plot_boundaries <- spline_plot_boundaries(EDJ_splines_binded)
splines_to_plot <- EDJ_splines_binded
}
plot3d(splines_to_plot[[a]],type="l",xlim=c(plot_boundaries$xmed-10,plot_boundaries$xmed+10),ylim=c(plot_boundaries$ymed-10,plot_boundaries$ymed+10),zlim=c(plot_boundaries$zmed-10,plot_boundaries$zmed+10),aspect =T,xlab="",ylab="",zlab="",box=F,axes=F,main="Splines shown in black")
if(analysis %in% c("EDJ CEJ", "EDJ")){
lines3d(EDJ_spline_mains$spline_1m[[a]],col="orange")
points3d(eq_EDJ$spline_1m[[a]])
texts3d(c(EDJ_spline_mains$spline_1m[[a]][as.integer(length(EDJ_spline_mains$spline_1m[[a]][,1])/2),]),texts = "EDJ 1",font=2)
lines3d(EDJ_spline_mains$spline_2m[[a]],col="red")
points3d(eq_EDJ$spline_2m[[a]])
texts3d(c(EDJ_spline_mains$spline_2m[[a]][as.integer(length(EDJ_spline_mains$spline_2m[[a]][,1])/2),]),texts = "EDJ 2",font=2)
if(any(grepl("M", position))){
lines3d(EDJ_spline_mains$spline_3m[[a]],col="blue")
points3d(eq_EDJ$spline_3m[[a]])
texts3d(c(EDJ_spline_mains$spline_3m[[a]][as.integer(length(EDJ_spline_mains$spline_3m[[a]][,1])/2),]),texts = "EDJ 3",font=2)
lines3d(EDJ_spline_mains$spline_4m[[a]],col="green")
points3d(eq_EDJ$spline_4m[[a]])
texts3d(c(EDJ_spline_mains$spline_4m[[a]][as.integer(length(EDJ_spline_mains$spline_4m[[a]][,1])/2),]),texts = "EDJ 4",font=2)
}
spheres3d(landmark_data_mats$EDJ_MAIN[[a]],radius=0.05)
if(analysis == "EDJ CEJ"){
points3d(eq_CEJ[[a]])
}
} else {
plot3d(splines_to_plot[[a]],type="l",xlim=c(plot_boundaries$xmed-10,plot_boundaries$xmed+10),ylim=c(plot_boundaries$ymed-10,plot_boundaries$ymed+10),zlim=c(plot_boundaries$zmed-10,plot_boundaries$zmed+10),aspect =T,xlab="",ylab="",zlab="",box=F,axes=F,main="Splines shown in black")
points3d(eq_CEJ[[a]])
}
plot3d(NewCoordsArray[,,a],type="l",xlim=c(plot_boundaries$xmed-10,plot_boundaries$xmed+10),ylim=c(plot_boundaries$ymed-10,plot_boundaries$ymed+10),zlim=c(plot_boundaries$zmed-10,plot_boundaries$zmed+10),aspect =T,xlab="",ylab="",zlab="",box=F,axes=F,main="Splines shown in black")
text3d(NewCoordsArray[,,a], texts = 1:dim(NewCoordsArray)[1],font=2,cex=1)
if(analysis %in% c("EDJ CEJ", "EDJ")){
curves <- vector("list", length(EDJ_nPoints))
npoint_vals <- unlist(EDJ_nPoints)
npoint_vals_l <- length(npoint_vals)
if(analysis == "EDJ CEJ"){
fix <- c(1, sapply(1:(length(npoint_vals)), function(i) sum(npoint_vals[1:i]) + (i+1)))
} else {
fix <- c(1, sapply(1:(length(npoint_vals)-1), function(i) sum(npoint_vals[1:i]) + (i+1)))
}
slid<-c(1:length(NewCoordsArray[,1,1]))[-c(fix)]
# offsets
offsets <- if(npoint_vals_l == 2){
rep(2, npoint_vals_l)
} else {
first_seq <- seq_along(npoint_vals[-1]) + 1
c(first_seq,  first_seq[3])
}
# cumulative ends
ends <- cumsum(npoint_vals) + offsets
# start indices
starts <- c(1, head(ends, -1))
# generate curves
curves <- mapply(function(s, e) s:e, starts, ends, SIMPLIFY = FALSE)
# special wrap-around rule
if(npoint_vals_l == 2){
curves[[2]] <- c(curves[[2]], 1)  # second curve wraps to 1
} else {
curves[[npoint_vals_l]] <- c(curves[[npoint_vals_l]], 1)  # last curve wraps to 1 in longer cases
}
names(curves) <- names(EDJ_nPoints)
if(analysis == "EDJ CEJ"){
curveCEJ <- c((sum(npoint_vals) + npoint_vals_l + 1):(sum(npoint_vals) + CEJ + npoint_vals_l + 1), (sum(npoint_vals) + npoint_vals_l + 1))
curves[[npoint_vals_l + 1]] <- curveCEJ
names(curves)[[npoint_vals_l + 1]] <- "CEJ1"
}
} else {
fix<-c(1)
curveCEJ <- c(1:(CEJ+1),1)
curves<-list(curveCEJ)
names(curves)<-"CEJ1"
slid<-c(1:length(NewCoordsArray[,1,1]))[-c(fix)]
}
# Make a template with the correct specimen names
template <- data.frame(Name=spec_names,Tooth=NA,Class1=NA,Class2=NA,Classify=NA,Exclude=NA)
template$Tooth <- str_extract(template$Name, ".{2}$")
template$Classify <- "*"
template$Exclude <- "*"
template$Class1 <- "*"
template$Class2 <- str_extract(template$Name, "^[^_]+")
if(length(position) > 1){
position_file <- paste(position, collapse = "_")
} else {
position_file <- position
}
write.table(template,paste(position_file,"_labels.csv",sep=""),col.names = T,row.names=F,sep =",",quote=F)
# write the number of landmarks used
write.table(num_landmarks_df, paste(position_file,"_n_landmarks.csv",sep=""),sep =" ", col.names = T, quote = F)
# Load filled in template
# spec_num<-length(spec_names) # Can't find where it is used?
classifierraw <-read.csv(paste(position_file,"_labels.csv",sep=""),header=TRUE)
keep<-classifierraw$Exclude!="ex"
classifier<-classifierraw[keep,]
classified<-classifier$Classify!="classify"
spec_names_kept <- spec_names[keep]
if(analysis %in% c("EDJ CEJ", "EDJ")){
# is it EDJ_spline_segments and not mains that need to be used....?
# EDJ_spline_mains - because we are projecting both the slide and main landmarks back, no?
EDJ_spline_subs <- lapply(seq_along(EDJ_spline_mains), function(spline_group){
sub <- EDJ_spline_mains[[spline_group]][keep]
names(sub) <- spec_names[keep]
sub
})
names(EDJ_spline_subs) <- paste0("EDJ", seq_along(EDJ_spline_subs))
datamat_EDJ_msub <- landmark_data_mats$EDJ_MAIN[keep]
if(analysis == "EDJ CEJ"){
CEJ_spline_sub<-CEJ_splines_binded[keep]
names(CEJ_spline_sub)<-spec_names[keep]
splines <- c(EDJ_spline_subs, list(CEJ = CEJ_spline_sub))
} else{
splines <- EDJ_spline_subs
}
} else {
CEJ_spline_sub<-CEJ_splines_binded[keep]
names(CEJ_spline_sub)<-spec_names[keep]
}
# Either "Tooth position" or "Taxonomy"
analysis_type <- "Taxonomy"
if(analysis_type == "Tooth position"){
gp <- as.factor(paste(classifier$Tooth)) # Tooth type
farbe <- c("black",
"#4daf4a",
"#e41a1c",
"#1874CD",
"#984ea3",
"orange",
"#53868B",
"#8B864E",
"#EEE8CD",
"darkslategray",
"#EE6AA7",
"#54FF9F"
)
} else {
gp <- as.factor(paste(classifier$Class1)) # Taxonomy
# set specific colours to group
group_colours <- data.frame(
matrix(
c("UW105", "black",
"Hhab", "#4daf4a",
"Pboi", "#984ea3",
"Prob", "#1874CD",
"Early Homo", "#FFA500",
"Aus", "#e41a1c",
"Paet", "#53868B",
"Hnal","#8B864E",
"Here", "darkslategray"
),
ncol = 2, byrow = T)
)
colnames(group_colours) <- c("group", "colour")
farbe <- c()
for(i in 1:nlevels(gp)){
gp_ind <- which(group_colours$group == levels(gp)[i])
farbe <- c(farbe, group_colours$colour[gp_ind])
}
}
dimnames(NewCoordsArray)[[3]] <- classifierraw$Name
SubCoordsArray<-NewCoordsArray[,,keep]
for(i in 1:dim(SubCoordsArray)[3]){
if(any(is.na(SubCoordsArray[,,i]))){
print(paste0("NA detected in the landmark coordinates of this specimens, check landmarks! ", spec_names_kept[i]))
}
}
# Drop landmarks
DROPLMs<-F
if (DROPLMs==TRUE) {
#todrop<- c(1:4,19:26,41:47)
todrop<-c(37:41)
#todrop<-c(1:46)
total<-c(1:length(SubCoordsArray[,,a][,1]))
tokeep<-total[-todrop]
} else {
tokeep<-c(1:length(SubCoordsArray[,,a][,1]))
todrop<-0
}
# First sliding step
slid1<-slider3d(dat.array=SubCoordsArray,SMvector=slid,outlines=curves,iterations = 1, stepsize = 1)
slid1_p<-array(dim=dim(slid1$dataslide))
for(a in 1:dim(slid1$dataslide)[3]){
if(analysis %in% c("EDJ CEJ", "EDJ")){
# Define segment boundaries and spline names dynamically
if(analysis == "EDJ CEJ"){
boundaries <- c(1, fix[2:length(fix)], dim(slid1$dataslide)[1] + 1)
spline_refs <- c(paste0("EDJ", 1:(length(fix)-1)), "CEJ")
} else {
boundaries <- c(1, fix[2:length(fix)], dim(slid1$dataslide)[1] + 1)
spline_refs <- paste0("EDJ", 1:(length(boundaries)-1))
}
# Use lapply to process each segment
projected_list <- lapply(seq_along(spline_refs), function(i){
seg_start <- boundaries[i]
seg_end <- boundaries[i+1] - 1
if(i == length(spline_refs)) seg_end <- dim(slid1$dataslide)[1] # Last segment
segment <- seg_start:seg_end
spline_name <- spline_refs[i]
if(spline_name == "CEJ"){
current_spline <- splines$CEJ[[a]]
} else {
current_spline <- splines[[spline_name]][[a]]
}
project_to_curve(slid1$dataslide[segment,,a], current_spline, stretch=0)$s
})
slid1_p[,,a] <- do.call(rbind, projected_list)
slid1_p[fix,,a] <- slid1$dataslide[fix,,a]
} else {
s1_p_C <- project_to_curve(slid1$dataslide[c(fix[1]:dim(slid1$dataslide)[1]),,a],
CEJ_spline_sub[[a]], stretch=0)
slid1_p[,,a] <- s1_p_C$s
slid1_p[fix,,a] <- slid1$dataslide[fix,,a]
}
}
for(i in 1:dim(slid1_p)[3]){
if(any(is.na(slid1_p[,,i]))){
print(i)
}
}
slid2<-slider3d(dat.array=slid1_p, SMvector=slid,outlines=curves,iterations = 1, stepsize = 1)
slid2_p<-array(dim=dim(slid1$dataslide))
for(a in 1:dim(slid1$dataslide)[3]){
if(analysis %in% c("EDJ CEJ", "EDJ")){
# Define segment boundaries and spline names dynamically
if(analysis == "EDJ CEJ"){
boundaries <- c(1, fix[2:length(fix)], dim(slid2$dataslide)[1] + 1)
spline_refs <- c(paste0("EDJ", 1:(length(fix)-1)), "CEJ")
} else {
boundaries <- c(1, fix[2:length(fix)], dim(slid2$dataslide)[1] + 1)
spline_refs <- paste0("EDJ", 1:(length(boundaries)-1))
}
# Use lapply to process each segment
projected_list <- lapply(seq_along(spline_refs), function(i){
seg_start <- boundaries[i]
seg_end <- boundaries[i+1] - 1
if(i == length(spline_refs)) seg_end <- dim(slid2$dataslide)[1] # Last segment
segment <- seg_start:seg_end
spline_name <- spline_refs[i]
if(spline_name == "CEJ"){
current_spline <- splines$CEJ[[a]]
} else {
current_spline <- splines[[spline_name]][[a]]
}
project_to_curve(slid2$dataslide[segment,,a], current_spline, stretch=0)$s
})
slid2_p[,,a] <- do.call(rbind, projected_list)
slid2_p[fix,,a] <- slid2$dataslide[fix,,a]
} else {
s2_p_C <- project_to_curve(slid2$dataslide[c(fix[1]:dim(slid2$dataslide)[1]),,a],
CEJ_spline_sub[[a]], stretch=0)
slid2_p[,,a] <- s2_p_C$s
slid2_p[fix,,a] <- slid2$dataslide[fix,,a]
}
}
Landmarks_slid <- slid2_p
a<-1
######
for(a in 1:length(spec_names_kept)){
clear3d("shapes");
if(analysis %in% c("EDJ CEJ", "EDJ")){
# Detect available spline types dynamically
edj_spline_names <- names(EDJ_spline_subs)[grepl("^EDJ", names(EDJ_spline_subs))]
EDJ_spline_length <- length(EDJ_spline_subs[[edj_spline_names[1]]])
# Function to get all splines for a given index
get_splines_for_index <- function(i) {
edj_splines <- setNames(lapply(edj_spline_names, function(name) EDJ_spline_subs[[name]][[i]]),
edj_spline_names)
edj_splines
}
# Get plot boundaries
plot_boundaries <- if(analysis == "EDJ CEJ") {
spline_plot_boundaries(CEJ_spline_sub)
} else {
spline_plot_boundaries(EDJ_spline_subs[[edj_spline_names[1]]])
}
# Create splines to plot
splines_to_plot <- lapply(1:EDJ_spline_length, function(i){
do.call(rbind, get_splines_for_index(i))
})
# Combined EDJ splines for lines3d
combined_edj_splines <- lapply(1:EDJ_spline_length, function(i){
do.call(rbind, lapply(edj_spline_names, function(name) EDJ_spline_subs[[name]][[i]]))
})
} else {
plot_boundaries <- spline_plot_boundaries(CEJ_spline_sub)
splines_to_plot <- CEJ_spline_sub
}
# Rest of plotting code remains the same...
plot3d(splines_to_plot[[a]], type="l", xlab="", ylab="", zlab="", aspect=T, box=F, axes=F,
xlim=c(plot_boundaries$xmed-10, plot_boundaries$xmed+10),
ylim=c(plot_boundaries$ymed-10, plot_boundaries$ymed+10),
zlim=c(plot_boundaries$zmed-10, plot_boundaries$zmed+10), col="gray")
if(analysis %in% c("EDJ CEJ", "EDJ")){
lines3d(combined_edj_splines[[a]], col="gray")
spheres3d(datamat_EDJ_msub[[a]], radius=0.1)
if(analysis == "EDJ CEJ"){
lines3d(CEJ_spline_sub[[a]], col="gray")
}
} else {
lines3d(CEJ_spline_sub[[a]], col="gray")
}
pch3d(SubCoordsArray[,,a], pch=19, cex=0.02, col="black")
pch3d(slid1$dataslide[,,a], pch=19, cex=0.02, col="#6767ff")
pch3d(slid1_p[,,a], pch=19, cex=0.04, col="#0000ff")
pch3d(slid2$dataslide[,,a], pch=19, cex=0.02, col="#ff7373")
pch3d(slid2_p[,,a], pch=19, cex=0.04, col="#ff0303")
n <- length(SubCoordsArray[,1,a])
Xslid1 <- rbind(SubCoordsArray[,,a], slid2_p[,,a])
OXslid1 <- Xslid1[as.vector(rbind(1:n, n + 1:n)), ]
try(arrows3d(OXslid1, scale=c(1,1,1), col="#ff0303"), silent=T)
readline(prompt=paste("Displaying", spec_names_kept[a], "; Press [Enter] to continue and [Esc] to exit", sep=" "))
}
Q
Include_size<-FALSE
# Procrustes registration
dimnames(Landmarks_slid)[3] <- dimnames(SubCoordsArray)[3]
Proc<-procSym(dataarray=Landmarks_slid,SMvector=NULL,outlines=curves, use.lm = tokeep, sizeshape = Include_size)
# Colours
# farbe<-c("black","#e41a1c","#984ea3","#377eb8","#4daf4a","black","black","#984ea3","black","black")
# Plot PCA PC1 V 2
plot(cbind(Proc$PCscores[,1],Proc$PCscores[,2]),type="n",asp=1,cex=1,
xlab=paste0("PC 1 ", "(", round(Proc$Variance[1,2], 2), "%", ")"),
ylab=paste0("PC 2 ", "(", round(Proc$Variance[2,2], 2), "%", ")"))
for(a in 1:length(levels(gp))){
sub<-gp==levels(gp)[a]
tr <- NULL
try(tr<-tri.mesh(x=Proc$PCscores[sub,1],y=Proc$PCscores[sub,2],duplicate = "error"))
if(!is.null(tr)){
polygon(convex.hull(tr)$x,convex.hull(tr)$y,col=(adjustcolor(farbe[a], alpha.f = 0.5)),border=farbe[a])
} else if(sum(sub)==2){
lines(Proc$PCscores[sub,1],Proc$PCscores[sub,2],col=farbe[a],lwd = 2)
}}
points(cbind(Proc$PCscores[,1],Proc$PCscores[,2]),col=farbe[gp],pch=19)
text(cbind(Proc$PCscores[,1],Proc$PCscores[,2]),label=dimnames(Proc$PCscores)[[1]],col=farbe[gp],pos=c(1,2),cex=0.6,offset=0.5)
legend("topright", legend = levels(gp), col = farbe, pch = 19, bty = "n")
gp
gp <- as.factor(paste(classifier$Class2)) # Taxonomy
# set specific colours to group
group_colours <- data.frame(
matrix(
c("UW105", "black",
"Hhab", "#4daf4a",
"Pboi", "#984ea3",
"Prob", "#1874CD",
"Early Homo", "#FFA500",
"Aus", "#e41a1c",
"Paet", "#53868B",
"Hnal","#8B864E",
"Here", "darkslategray"
),
ncol = 2, byrow = T)
)
colnames(group_colours) <- c("group", "colour")
farbe <- c()
for(i in 1:nlevels(gp)){
gp_ind <- which(group_colours$group == levels(gp)[i])
farbe <- c(farbe, group_colours$colour[gp_ind])
}
Include_size<-FALSE
# Procrustes registration
dimnames(Landmarks_slid)[3] <- dimnames(SubCoordsArray)[3]
Proc<-procSym(dataarray=Landmarks_slid,SMvector=NULL,outlines=curves, use.lm = tokeep, sizeshape = Include_size)
# Colours
# farbe<-c("black","#e41a1c","#984ea3","#377eb8","#4daf4a","black","black","#984ea3","black","black")
# Plot PCA PC1 V 2
plot(cbind(Proc$PCscores[,1],Proc$PCscores[,2]),type="n",asp=1,cex=1,
xlab=paste0("PC 1 ", "(", round(Proc$Variance[1,2], 2), "%", ")"),
ylab=paste0("PC 2 ", "(", round(Proc$Variance[2,2], 2), "%", ")"))
for(a in 1:length(levels(gp))){
sub<-gp==levels(gp)[a]
tr <- NULL
try(tr<-tri.mesh(x=Proc$PCscores[sub,1],y=Proc$PCscores[sub,2],duplicate = "error"))
if(!is.null(tr)){
polygon(convex.hull(tr)$x,convex.hull(tr)$y,col=(adjustcolor(farbe[a], alpha.f = 0.5)),border=farbe[a])
} else if(sum(sub)==2){
lines(Proc$PCscores[sub,1],Proc$PCscores[sub,2],col=farbe[a],lwd = 2)
}}
points(cbind(Proc$PCscores[,1],Proc$PCscores[,2]),col=farbe[gp],pch=19)
text(cbind(Proc$PCscores[,1],Proc$PCscores[,2]),label=dimnames(Proc$PCscores)[[1]],col=farbe[gp],pos=c(1,2),cex=0.6,offset=0.5)
legend("topright", legend = levels(gp), col = farbe, pch = 19, bty = "n")
# Plot PCA PC1 V 3
plot(cbind(Proc$PCscores[,1],Proc$PCscores[,3]),type="n",asp=1,cex=1,
xlab=paste0("PC 1 ", "(", round(Proc$Variance[1,2], 2), "%", ")"),
ylab=paste0("PC 3 ", "(", round(Proc$Variance[3,2], 2), "%", ")"))
for(a in 1:length(levels(gp))){
sub<-gp==levels(gp)[a]
tr <- NULL
try(tr<-tri.mesh(x=Proc$PCscores[sub,1],y=Proc$PCscores[sub,3],duplicate = "error"))
if(!is.null(tr)){
polygon(convex.hull(tr)$x,convex.hull(tr)$y,col=(adjustcolor(farbe[a], alpha.f = 0.5)),border=farbe[a])
} else if(sum(sub)==2){
lines(Proc$PCscores[sub,1],Proc$PCscores[sub,3],col=farbe[a],lwd = 2)
}}
points(cbind(Proc$PCscores[,1],Proc$PCscores[,3]),col=farbe[gp],pch=19)
# text(cbind(Proc$PCscores[,1],Proc$PCscores[,3]),label=dimnames(Proc$PCscores)[[1]],col=farbe[gp],pos=c(3),cex=0.6,offset=0.5)
legend("topright", legend = levels(gp), col = farbe, pch = 19, bty = "n")
text(cbind(Proc$PCscores[,1],Proc$PCscores[,3]),label=dimnames(Proc$PCscores)[[1]],col=farbe[gp],pos=c(3),cex=0.6,offset=0.5)
# compare specimens
as.matrix(classifier$Name)
library(gtools)
library(matlib)
library(geomorph)
library(Morpho)
library(princurve)
library(tripack)
library(stringr)
library(geometry)
library(randomcoloR)
library(Rvcg)
# Plot PCA PC1 V 2
plot(cbind(Proc$PCscores[,1],Proc$PCscores[,2]),type="n",asp=1,cex=1,
xlab=paste0("PC 1 ", "(", round(Proc$Variance[1,2], 2), "%", ")"),
ylab=paste0("PC 2 ", "(", round(Proc$Variance[2,2], 2), "%", ")"))
for(a in 1:length(levels(gp))){
sub<-gp==levels(gp)[a]
tr <- NULL
try(tr<-tri.mesh(x=Proc$PCscores[sub,1],y=Proc$PCscores[sub,2],duplicate = "error"))
if(!is.null(tr)){
polygon(convex.hull(tr)$x,convex.hull(tr)$y,col=(adjustcolor(farbe[a], alpha.f = 0.5)),border=farbe[a])
} else if(sum(sub)==2){
lines(Proc$PCscores[sub,1],Proc$PCscores[sub,2],col=farbe[a],lwd = 2)
}}
points(cbind(Proc$PCscores[,1],Proc$PCscores[,2]),col=farbe[gp],pch=19)
text(cbind(Proc$PCscores[,1],Proc$PCscores[,2]),label=dimnames(Proc$PCscores)[[1]],col=farbe[gp],pos=c(1,2),cex=0.6,offset=0.5)
legend("topright", legend = levels(gp), col = farbe, pch = 19, bty = "n")
